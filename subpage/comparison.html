<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Box Plot</title>

</head>

<style>
  .container1 {
    display: flex;
    flex-direction: column;
    height: 76vh;
  }

  .box1,
  .box2 {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .flex-hori {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .char-div {
    width: 50%;
    height: 38vh;
  }
</style>

<body>
  <div class="layerPopup">
    <div class="spinner"></div>
  </div>
  <div style="display: flex;margin: auto;">

    <div style="display: flex;margin: auto;">
      <div style="width: 300px;">
        <select id="select-tools" multiple placeholder="Target"></select>
      </div>
      <div style="width: 300px;margin-left: 10px;">
        <select id="select-tools1" multiple placeholder="Group by"></select>
      </div>
      <button id="apply-btn" type="button" class="btn btn-primary" style="margin-left: 10px;">
        Apply
      </button>
    </div>
  </div>

  <div class="container1">
    <div class="box1">
      <div id="myDiv0" class="char-div"></div>
      <div id="myDiv1" class="char-div"></div>
    </div>

    <div class="box2">
      <div id="myDiv2" class="char-div"></div>
      <div id="myDiv3" class="char-div"></div>
    </div>
  </div>

  <div class="flex-hori">
    <div id="page-index"></div>
  </div>

  <div class="flex-hori">
    <button id="pre-btn" type="button" class="btn btn-primary">
      Pre
    </button>
    <button id="next-btn" type="button" class="btn btn-primary" style="margin-left: 10px;">
      Next
    </button>
  </div>


  <script>

    var preBtn = $("#pre-btn")
    preBtn.prop("disabled", true)
    var nextBtn = $("#next-btn")
    nextBtn.prop("disabled", true)
    var pageIndex = $("#page-index")

    var $select = $('#select-tools').selectize({
      plugins: ["remove_button"],
      maxItems: 1,
      maxOptions: 100,
      valueField: 'id',
      labelField: 'title',
      searchField: 'title',
      options: [],
      create: false,
    });

    var $select1 = $('#select-tools1').selectize({
      plugins: ["remove_button"],
      maxItems: 1,
      maxOptions: 100,
      valueField: 'id',
      labelField: 'title',
      searchField: 'title',
      options: [],
      create: false
    });



    var allUniqueValue = new Map();
    var allPatient = new Map();
    var proteinPatient = []
    var genePatient = []
    var acetlysitePatient = []
    var phosphositePatient = []
    var allProtein = new Map();
    var allGene = new Map();
    var allAcetlysite = new Map();
    var allPhosphosite = new Map();
    var patientInfo = [];
    var targetOptions = []
    var index = 1



    function getData() {
      showSpinner();
      const patientData = metaArray;
      const rowHeader = [];
      patientData.map((row) => {
        const rowData = row.split(",");
        rowHeader.push(rowData[0]);
        let uniqueValue = unique(rowData.slice(1));
        allUniqueValue.set(rowData[0], uniqueValue);
      });
      allUniqueValue.delete('Sample.ID');
      allUniqueValue.delete('Subtype Membership');
      allUniqueValue.delete('Age');
      //get patientInfo
      for (let i = 1; i < patientData[0].split(",").length; i++) {
        patientInfo.push(new PatientMetaData());
      }
      for (let i = 0; i < rowHeader.length; i++) {
        let row = patientData[i].split(",").slice(1)
        for (let j = 0; j < row.length; j++) {
          patientInfo[j][rowHeader[i]] = row[j];
        }
      }
      patientInfo.forEach((value) => {
        allPatient.set(value['Sample.ID'], value)
      });


      $.ajax({
        type: "GET",
        url: "../file/Quantitation_proteins.csv",
        dataType: "text",
        cache: false,
        success: function (data) {
          data = data.split("\n");
          proteinPatient = data[0].split(",").slice(2);
          for (let i = 1; i < data.length; i++) {
            const row = data[i].split(",")
            allProtein.set(row[0], row.slice(2))
          }
          //"RE-P231-T\r"
          let last = proteinPatient[proteinPatient.length - 1]
          proteinPatient[proteinPatient.length - 1] = last.substring(0, last.length - 1)
          // 这里的样本包含正常样本，但是meta数据只有癌症患者，所以在分类数据时去除正常患者
          // console.log(proteinPatient)
          // console.log(allProtein)
          for (const key of allProtein.keys()) {
            targetOptions.push({ id: index, title: key })
            index++;
          }
          $.ajax({
            type: "GET",
            url: "../file/Quantitation_acetyl.csv",
            dataType: "text",
            cache: false,
            success: function (data) {
              data = data.split("\n");
              acetlysitePatient = data[0].split(",").slice(2);
              for (let i = 1; i < data.length; i++) {
                const row = data[i].split(",")
                allAcetlysite.set(row[0], row.slice(2))
                allAcetlysite.set(row[2], row.slice(2))
              }
              //"RE-P231-T\r"
              let last = acetlysitePatient[acetlysitePatient.length - 1]
              acetlysitePatient[acetlysitePatient.length - 1] = last.substring(0, last.length - 1)
              // 这里的样本包含正常样本，但是meta数据只有癌症患者，所以在分类数据时去除正常患者
              // console.log(acetlysitePatient)
              // console.log(allAcetlysite)
              for (const key of allAcetlysite.keys()) {
                targetOptions.push({ id: index, title: key })
                index++;
              }

              $.ajax({
                type: "GET",
                url: "../file/Quantitation_phospho.csv",
                dataType: "text",
                cache: false,
                success: function (data) {
                  data = data.split("\n");
                  phosphositePatient = data[0].split(",").slice(2);
                  for (let i = 1; i < data.length; i++) {
                    const row = data[i].split(",")
                    allPhosphosite.set(row[0], row.slice(2))
                    allPhosphosite.set(row[2], row.slice(2))
                  }
                  let last = phosphositePatient[phosphositePatient.length - 1]
                  phosphositePatient[phosphositePatient.length - 1] = last.substring(0, last.length - 1)
                  // 这里的样本包含正常样本，但是meta数据只有癌症患者，所以在分类数据时去除正常患者
                  // console.log(phosphositePatient)
                  // console.log(allPhosphosite)
                  for (const key of allPhosphosite.keys()) {
                    targetOptions.push({ id: index, title: key })
                    index++;
                  }

                  $.ajax({
                    type: "GET",
                    url: "../file/Quantitation_genes.csv",
                    dataType: "text",
                    cache: false,
                    success: function (data) {
                      data = data.split("\n");
                      genePatient = data[0].split(",").slice(1);
                      for (let i = 1; i < data.length; i++) {
                        const row = data[i].split(",")
                        allGene.set(row[0], row.slice(1))
                      }
                      //去除多余空值
                      genePatient = genePatient.slice(0, genePatient.indexOf(''))
                      // console.log(genePatient)
                      // console.log(allGene)
                      for (const key of allGene.keys()) {
                        targetOptions.push({ id: index, title: key })
                        index++;
                      }

                      let groupOptions = []
                      index = 1
                      for (const key of allUniqueValue.keys()) {
                        groupOptions.push({ id: index, title: key })
                        index++;
                      }
                      var selectizeControl = $select[0].selectize;
                      selectizeControl.addOption(targetOptions)
                      var selectizeControl1 = $select1[0].selectize;
                      selectizeControl1.addOption(groupOptions)
                      hideSpinner()
                    },
                  });
                },
              });
            },
          });
        },
      });
    }
    getData()

    function unique(array) {
      return array.filter((value, index, self) => {
        return value !== 'None' && value !== '' && self.indexOf(value) === index;
      });
    }

    var res = new Map()
    var page = 0
    var limit = 0
    var groupValue = ""
    $("#apply-btn").click(function () {
      res = new Map()
      page = 0
      const targetValue = $('#select-tools').text();
      groupValue = $('#select-tools1').text();
      let uniqueValue = allUniqueValue.get(groupValue);
      uniqueValue = uniqueValue.sort()

      let targetArray = new Map();
      let targetPatient = new Map();
      if (allGene.has(targetValue)) {
        targetArray.set(targetValue, allGene.get(targetValue))
        targetPatient.set(targetValue, genePatient)
      }
      if (allProtein.has(targetValue)) {
        targetArray.set(targetValue, allProtein.get(targetValue))
        targetPatient.set(targetValue, proteinPatient)
      }
      for (const [key, value] of allAcetlysite) {
        if (key.split("_")[0] !== targetValue) continue;
        targetArray.set(key, value)
        targetPatient.set(key, acetlysitePatient)
      }
      for (const [key, value] of allPhosphosite) {
        if (key.split("_")[0] !== targetValue) continue;
        targetArray.set(key, value)
        targetPatient.set(key, phosphositePatient)
      }

      for (const [key, value] of targetArray) {
        let curArray = value;
        let curTarget = key;
        let curPatient = targetPatient.get(curTarget)
        let data = [];
        for (var i = 0; i < uniqueValue.length; i++) {
          data.push({
            y: [],
            type: "box",
            name: uniqueValue[i],
            marker: {
              color: color[i],
            },
          })
        }
        curArray.forEach((value, index) => {
          if (allPatient.has(curPatient[index])) {
            const curPatientInfo = allPatient.get(curPatient[index]);
            for (var i = 0; i < uniqueValue.length; i++) {
              if (curPatientInfo[groupValue] === uniqueValue[i]) {
                data[i]["y"].push(value);
                break;
              }
            }
          }
        })
        res.set(curTarget, data)
      }
      limit = Math.ceil(res.size / 4)
      draw(res)
    })

    function draw(res) {
      if (res.size !== 0) {
        pageIndex.text((page + 1) + "/" + limit)
        if (page === 0) preBtn.prop("disabled", true)
        else preBtn.prop("disabled", false)
        if ((page + 1) == limit) nextBtn.prop("disabled", true)
        else nextBtn.prop("disabled", false)
      }
      for (let i = 0; i < 4; i++) {
        Plotly.purge("myDiv" + i)
      }
      let allKeys = Array.from(res.keys())
      let start = page * 4
      allKeys = allKeys.slice(start, start + 4)
      allKeys.forEach((value, index) => {
        let data = res.get(value)
        let pValue = 0
        let pText = ""
        if (data.length > 2) pValue = kruskalWallisTest(data)
        else pValue = wilcoxonRankSumTest(data)
        if (pValue < 0.01) {
          console.log(pValue)
          pText = "p < 0.01"
        } else {
          // console.log(pValue, parseFloat(pValue.toFixed(2)))
          pText = "p = " + parseFloat(pValue.toFixed(2));
        }
        var layout = {
          title: value,
          xaxis: {
            title: {
              text: groupValue,
            }
          },
          annotations: [
            {
              x: 0.01, // 相对于图表宽度的位置
              y: 1.1, // 相对于图表高度的位置
              xref: 'paper', // x 坐标轴的参考设置为 'paper'
              yref: 'paper', // y 坐标轴的参考设置为 'paper'
              text: pText, // 要显示的文本
              showarrow: false, // 是否显示箭头指向注释
              font: {
                size: 12
              }
            }
          ]
        };

        Plotly.newPlot("myDiv" + index, data, layout);
      })
    }
    preBtn.click(function () {
      page--;
      draw(res)
    })

    nextBtn.click(function () {
      page++;
      draw(res)
    })


    function wilcoxonRankSumTest(data) {
      // 使用 map 获取所有的 y 数组
      let yArrays = data.map(item => item.y);

      // 合并两组数据
      let combinedData = [].concat(...yArrays);

      // 对合并后的数据进行排序
      combinedData.sort((a, b) => a - b);

      // 将数据分成两组，每组对应不同的样本
      let group1 = yArrays[0];
      let group2 = yArrays[1];

      // 计算秩和
      let rankSum1 = 0;
      for (let i = 0; i < group1.length; i++) {
        rankSum1 += combinedData.indexOf(group1[i]) + 1;
      }

      let rankSum2 = 0;
      for (let i = 0; i < group2.length; i++) {
        rankSum2 += combinedData.indexOf(group2[i]) + 1;
      }

      // 计算 U 统计量
      let n1 = group1.length;
      let n2 = group2.length;
      let U1 = rankSum1 - (n1 * (n1 + 1)) / 2;
      let U2 = rankSum2 - (n2 * (n2 + 1)) / 2;

      // 计算较小的 U 统计量
      let U = Math.min(U1, U2);

      // 计算期望值和方差
      let expectedValue = (n1 * n2) / 2;
      let variance = (n1 * n2 * (n1 + n2 + 1)) / 12;

      // 计算 Z 统计量
      let zStat = (U - expectedValue) / Math.sqrt(variance);

      // 计算 p 值
      let pValue = jStat.normal.cdf(zStat, 0, 1);

      return pValue * 2; // 乘以2以获得双尾检验的p值
    }


    function anova(data) {

      // 使用 map 获取所有的 y 数组
      let yArrays = data.map(item => item.y);

      // 使用 concat 和 spread 运算符来合并这些数组
      let concatenatedY = [].concat(...yArrays);

      // 计算总体均值 (Grand Mean)
      // jStat.mean([1,2,3])
      const yMean = math.mean(concatenatedY);

      // 计算组间平方和 (SSB) 和组间自由度 (dfB)
      let ssb = 0;
      const yMeans = yArrays.map(y => math.mean(y));
      yArrays.forEach((y, i) => {
        ssb += y.length * Math.pow(yMeans[i] - yMean, 2);
      });
      const dfB = yArrays.length - 1;


      // 计算组内平方和 (SSW) 和组内自由度 (dfW)
      let ssw = 0;
      yArrays.forEach((y, i) => {
        y.forEach(value => {
          ssw += Math.pow(value - yMeans[i], 2);
        });
      });
      const dfW = concatenatedY.length - yArrays.length;


      // 计算 F-统计量
      const fStat = (ssb / dfB) / (ssw / dfW);

      // 计算 p-值
      const pValue = 1 - jStat.centralF.cdf(fStat, dfB, dfW);


      return pValue;
    }

    function kruskalWallisTest(data) {
      // 使用 map 获取所有的 y 数组
      let yArrays = data.map(item => item.y);

      let allData = [];

      for (let i = 0; i < yArrays.length; i++) {
        allData = allData.concat(yArrays[i]);
      }
      
      // console.log(allData);
      const ranks = jStat.rank(allData);
      // console.log(ranks);
      const n = allData.length;

      let sumRanks = [];

      for (let i = 0; i < yArrays.length; i++) {
        let rankSum = 0;

        for (let j = 0; j < yArrays[i].length; j++) {
          rankSum += ranks.shift();
        }

        sumRanks.push(rankSum);
      }
      // H = (12 / (N(N + 1))) * Σ(R^2 / ni) - 3(N + 1)

      let reducedSum = 0
      for (let i = 0; i < yArrays.length; i++) {
        reducedSum += Math.pow(sumRanks[i], 2) / yArrays[i].length
      }

      const hStat = (12 / (n * (n + 1))) * reducedSum - 3 * (n + 1);

      const df = yArrays.length - 1;

      // 计算卡方分布的p值（使用逆变换函数）
      const pValue = 1 - jStat.chisquare.cdf(hStat, df);

      return pValue;
    }







  </script>
</body>

</html>
</script>
</body>

</html>