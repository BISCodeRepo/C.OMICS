<!DOCTYPE html>
<meta charset="utf-8">
<style>

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

svg text{
    font-family:optima;
}

svg text .title{
    font-size: 2em;
}

.lifespan .outside_brush {
    fill-opacity: 0.1
}


</style>
<body>
    <div id="tester" style="width:800px;height:600px;"></div>
    <div id = "chart"></div>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="https://d3js.org/d3-selection-multi.v1.min.js"></script>
<script src="https://cdn.plot.ly/plotly-2.25.2.min.js" charset="utf-8"></script>
<script>

const Pi = 3.141592
var test = {}
var data_high_list = ["RE-P001-T","RE-P002-T","RE-P003-T","RE-P004-T","RE-P005-T"]

var min_date = 0
//var max_date = d3.max(data, (d)=>d.time)
var max_date = 11

    d3.csv("../file/Overall_survivals.csv", function(raw_data){

function filterHigh(obj){
    if (data_high_list.includes(obj.sample)){
        return obj.sample;
    }
    //console.log(data_high.includes(obj.sample)) 
}

function filterLow(obj){
    if (data_high_list.includes(obj.sample)){
    }
    else{
        return obj.sample;
    }
    
    //console.log(data_high.includes(obj.sample)) 
}

//Data cleaning:
var data = raw_data.map(function(d){
    var new_d = {}
    // new_d.age_entry_year = +d.ageentry/12; //patient start
    // new_d.age_year = +d.age/12;            //patient end
    new_d.time = +d.os/12
    new_d.death    = d.death  == "Y" ? true : false;
    new_d.sample = d.Sample
    //console.log(new_d.sample)
    // new_d.gender   = d.gender == "2" ? "female" : "male"
    return new_d;
    })
    .sort(d => d.time)
    //.filter(filterLow)

var data_high = data.filter(filterHigh)
var data_low = data.filter(filterLow)
        
var table_high = KM_Curve(data_high);
kmsurv_high = table_high[0];
censor_high = table_high[1];

var table_low = KM_Curve(data_low);
kmsurv_low = table_low[0]
censor_low = table_low[1]

//console.log(censor_low)

kmsurv_high.unshift({"t_i": min_date, "d_i": 0, "Y_i": 0, "s_t": 0, "S_t": 1})
kmsurv_low.unshift({"t_i": min_date, "d_i": 0, "Y_i": 0, "s_t": 0, "S_t": 1})
censor_high.unshift({"c_i": min_date, "c_s": 1})
censor_low.unshift({"c_i": min_date, "c_s": 1})

data_table = log_rank_Test(data,data_high,data_low)
        //console.log(data_table)
g1 = data_table[0]
g2 = data_table[1]
for(let i = 0; i < g1.length; i++){
    g1[i].e_i = (g1[i].n_i/(g1[i].n_i + g2[i].n_i)) * (g1[i].m_i+g2[i].m_i)
    g2[i].e_i = (g2[i].n_i/(g1[i].n_i + g2[i].n_i)) * (g1[i].m_i+g2[i].m_i)
    }
        
for(let i = 0; i < g1.length; i++){
    g1[i].o_i = g1[i].m_i - g1[i].e_i
    g2[i].o_i = g2[i].m_i - g2[i].e_i
    }
        
variance = 0
for(let i = 0; i < g1.length; i++){
    if (g1[i].n_i + g2[i].n_i == 1){
        variance += 0
        }
    else{
        variance += ((g1[i].n_i*g2[i].n_i)*(g1[i].m_i + g2[i].m_i)*(g1[i].n_i+g2[i].n_i - g1[i].m_i-g2[i].m_i))/((g1[i].n_i + g2[i].n_i)*(g1[i].n_i + g2[i].n_i)*(g1[i].n_i + g2[i].n_i-1))
        }   
    //console.log(variance)
    }
        
sum_o = 0
for(let i = 0; i < g1.length; i++){
    sum_o += g2[i].o_i
    }   
        
log_rank_test_val = sum_o**2/variance
//console.log(g1)
//console.log(log_rank_test_val)
        //import myModule from './my-module';
p_val = ChiSq(log_rank_test_val, 1).toFixed(4)
//console.log(p_val)


trace1 = {
  x: kmsurv_high.map((item) => item.t_i),
  y: kmsurv_high.map((item) => item.S_t),
  mode: 'lines',
  name: 'high',
  
  line: {shape: 'vh', color: 'red'},
};

trace2 = {
  x: kmsurv_low.map((item) => item.t_i),
  y: kmsurv_low.map((item) => item.S_t),
  mode: 'lines',
  name: 'low',
  
  line: {shape: 'hv', color: 'blue'},
};

trace3 = {
  x: censor_low.map((item) => item.c_t),
  y: censor_low.map((item) => item.c_s),
  mode: 'markers',
  marker: { size: 6, color: 'blue' },
  showlegend :false
}
trace4 = {
  x: censor_high.map((item) => item.c_t),
  y: censor_high.map((item) => item.c_s),
  mode: 'markers',
  marker: { size: 6, color: 'red' },
  showlegend :false
}

var data = [trace1, trace2, trace3, trace4];

var layout = {
    title : {
        text : "type of DNA<br>P-value = " + p_val,
    },

   yaxis:{
        autotick: false,
        ticks: 'outside',
        tick0: 0,
        dtick: 0.25,
        range : [0,1]
    },
  legend: {
    autosize : false,
    font: {size: 16},
    yref: 'paper',
    title : p_val
  }};

Plotly.newPlot('tester', data, layout);

function KM_Curve(data){
    //Source http://stackoverflow.com/questions/11246758/how-to-get-unique-values-in-an-array
    Array.prototype.contains = function(v) {
        for(var i = 0; i < this.length; i++) {
            if(this[i] === v) return true;
        }
        return false;
    };
    Array.prototype.unique = function() {
        var arr = [];
        for(var i = 0; i < this.length; i++) {
            if(!arr.contains(this[i])) {
                arr.push(this[i]);
            }
        }
        return arr;
    }

    //get unique times of death.
    var death_times = data.filter(d => d.death)
        .map(d => d.time)
        .sort()
    var censored_times = data.filter(d => !d.death)
        .map(d => parseFloat(d.time))
        //censored_times = censored_times.map(v=>parseFloat(v))
    
    var censored_times_sorted = censored_times.sort(function(a, b)  {
        return a - b;
        });
    
    var km_table = death_times.map(t_i => {
        var d_i = data.filter(d => d.time == t_i && d.death).length

        var Y_i = data.filter(d => d.time >= t_i).length

        var s_t = 1 - (d_i/Y_i);

        return {"t_i": t_i, "d_i": d_i, "Y_i": Y_i, "s_t": s_t}
    })
    
    //console.log(km_table);
    //console.log(km_table);
    

    var censor_table = []
    /*console.log("censored_time")
    console.log(censored_times)
    console.log("---------------")
    console.log("censored_time_sorted")
    console.log(censored_times_sorted)
    console.log("--------------")
    console.log("death_time")
    console.log(death_times)
    console.log("------------")
    */
    j = 0
    var prev_km = 1
    var cur_km = 1
    for (let [i, row] of km_table.entries()) {
        var t = row.t_i,
            s_t = row.s_t,
            last_S_t = i != 0 ? km_table[i-1].S_t : 1;
        km_table[i].S_t = last_S_t * s_t;
        if (i>0){
            prev_km = km_table[i-1].S_t
            cur_km = km_table[i].S_t
        }
        while(true){
            if (censored_times_sorted[j]<row.t_i){
                censor_table[j] = {"c_t" : censored_times_sorted[j], "c_s" : prev_km}
                j ++;
            }
            else{
                break
            }
        }
    }
    console.log(censor_table)
    for(let i = j; i < censored_times_sorted.length; i++){
        censor_table[i] = {"c_t" : censored_times_sorted[i], "c_s" : cur_km}
    }
    console.log(censor_table)
    //console.log(km_table)
    //console.log(censor_table)
    

    // console.table(km_table)
    km_table[km_table.length] = {"t_i": max_date, "d_i": max_date, "Y_i": max_date, "S_t": cur_km}
    return [km_table, censor_table];
}

function ChiSq(x,n) {
    if(n==1 & x>1000) {return 0}
    if(x>1000 | n>1000) {
        var q=ChiSq((x-n)*(x-n)/(2*n),1)/2
        if(x>n) {return q} {return 1-q}
        }
    var p=Math.exp(-0.5*x); if((n%2)==1) { p=p*Math.sqrt(2*x/Pi) }
    var k=n; while(k>=2) { p=p*x/k; k=k-2 }
    var t=p; var a=n; while(t>0.0000000001*p) { a=a+2; t=t*x/a; p=p+t }
    return 1-p
    }

function log_rank_Test(data,high,low){

    death_times_high = high.filter(d => d.death)
        .map(d => d.time)
        .sort()
    death_times_low = low.filter(d => d.death)
        .map(d => d.time)
        .sort()
    
    censored_times_high = high.filter(d => !d.death)
        .map(d => parseFloat(d.time))
        //censored_times = censored_times.map(v=>parseFloat(v))
    
    censored_times_sorted_high = censored_times_high.sort(function(a, b)  {
        return a - b;
        });
    censored_times_low = low.filter(d => !d.death)
        .map(d => parseFloat(d.time))
        //censored_times = censored_times.map(v=>parseFloat(v))
    
    censored_times_sorted_low = censored_times_low.sort(function(a, b)  {
        return a - b;
        });
    prev_t = 0
    var group1 = data.map(t_i => {
        var m_i = death_times_high.filter(d => d == t_i.time).length

        var n_i = high.filter(d => d.time >= t_i.time).length
        
        var q_i = censored_times_sorted_high.filter(d=>d <= t_i.time && d.time > prev_t).length
        
        prev_t = t_i.time
        return {"t_i": t_i.time, "n_i": n_i, "m_i": m_i, "q_t": q_i}
    })
    var group2 = data.map(t_i => {
        var m_i = death_times_low.filter(d => d == t_i.time).length

        var n_i = low.filter(d => d.time >= t_i.time).length
        
        var q_i = censored_times_sorted_low.filter(d=>d <= t_i.time && d > prev_t).length
        
        prev_t = t_i.time
        return {"t_i": t_i.time, "n_i": n_i, "m_i": m_i, "q_t": q_i}
    })

    return [group1, group2]
}

})
	
</script>
